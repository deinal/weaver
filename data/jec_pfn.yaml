selection:

new_variables:
   ch_mask: ak.ones_like(ch_pt)
   ne_mask: ak.ones_like(ne_pt)
   sv_mask: ak.ones_like(sv_pt)

preprocess:
   ### method: [manual, auto] - whether to use manually specified parameters for variable standardization
   method: manual
   ### data_fraction: fraction of events to use when calculating the mean/scale for the standardization
   data_fraction:

inputs:
   ch_features:
      length: 64
      vars:
         - ch_pt
         - ch_eta
         - ch_phi
         - ch_dxy
         - ch_dxy_significance
         - ch_dz
         - ch_num_hits
         - ch_num_pixel_hits
         - ch_lost_hits
         - ch_norm_chi2
         - ch_pv_ass
         - ch_id
   ch_mask:
      length: 64
      vars:
         - ch_mask
   ne_features:
      length: 64
      vars:
         - ne_pt
         - ne_eta
         - ne_phi
         - ne_hcal_frac
         - ne_id
   ne_mask:
      length: 64
      vars:
         - ne_mask
   sv_features:
      length: 16
      vars:
         - sv_pt
         - sv_eta
         - sv_phi
         - sv_mass
         - sv_distance
         - sv_significance
         - sv_num_tracks
   sv_mask:
      length: 16
      vars:
         - sv_mask
   jet_features:
      length:
      vars:
         - pt
         - eta
         - phi
         - mass
         - area
         - rho
         - num_pv


labels:
   ### type can be `simple`, `custom`
   ### [option 1] use `simple` for binary/multi-class classification, then `value` is a list of 0-1 labels
   ### [option 2] otherwise use `custom` to define the label, then `value` is a map
   type: custom
   value: 
      target: np.log(pt_gen / pt)

observers:
   - pt
   - pt_gen
   - pt_full_corr
   - eta_gen
   - parton_flavor
   - hadron_flavor

weights:
